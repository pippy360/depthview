<html>
<script src="js/three.min.js"></script>
<script>
    var camera, scene, renderer;
    var geometry, material, mesh, meshes = [];


    function init(imgData, imgWidth, imageHeight) {

        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 10 );
        camera.position.z = 1;

        scene = new THREE.Scene();

        geometry = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );
        material = new THREE.MeshNormalMaterial();

        mesh = new THREE.Mesh( geometry, material );

        //scene.add( mesh );
        for (var i = 0; i < imgData.length/4; i++){
            var depthVal = imgData[i*4]/255.0;
            var depthVal2 = imgData[i*4];
            var xPos = i%imgWidth;
            var yPos = parseInt(i/imgWidth);
            console.log("x: " + xPos + " y:" + yPos)
            var geometry = new THREE.SphereGeometry( 0.01, 0.01, 1 );
            var material = new THREE.MeshBasicMaterial( {color: "rgb(" + depthVal2 + ", " + depthVal2 + ", " + depthVal2 + ")" } );
            var sphere = new THREE.Mesh( geometry, material );
            sphere.position.set(xPos/imgWidth + (-0.5), -1*(yPos/imageHeight + (-0.5)), -1*(depthVal));
            scene.add( sphere );
            meshes.push( sphere );
        }

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize( 800, 600 );
        document.body.appendChild( renderer.domElement );
    }

    var rotWorldMatrix;
    // Rotate an object around an arbitrary axis in world space
    function rotateAroundWorldAxis(object, axis, radians) {
        rotWorldMatrix = new THREE.Matrix4();
        rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);

        // old code for Three.JS pre r54:
        //  rotWorldMatrix.multiply(object.matrix);
        // new code for Three.JS r55+:
        rotWorldMatrix.multiply(object.matrix);                // pre-multiply

        object.matrix = rotWorldMatrix;

        // old code for Three.js pre r49:
        // object.rotation.getRotationFromMatrix(object.matrix, object.scale);
        // old code for Three.js pre r59:
        // object.rotation.setEulerFromRotationMatrix(object.matrix);
        // code for r59+:
        object.rotation.setFromRotationMatrix(object.matrix);
    }

    var rot = 0;

    function animate() {

        requestAnimationFrame( animate );
        rot += .01;
        if (rot > 359){
            rot = 0
        }
        var xAxis = new THREE.Vector3(1,0,0);
        for (var i = 0; i < meshes.length; i++){
            meshT = meshes[i]
            //rotateAroundWorldAxis(meshT, xAxis, rot * Math.PI/180)
            pos1 = new THREE.Matrix4().makeTranslation(0.01, 0.01, 0.01)
            rot1 = new THREE.Matrix4().makeRotationZ(0.01)
            pos2 = new THREE.Matrix4().makeTranslation(-0.01, -0.01, -0.01)
            //meshT.geometry.applyMatrix( pos1*rot1*(pos2) );
        }
        renderer.render( scene, camera );

    }


    function getBase64Image(img) {
        // Create an empty canvas element
        var canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;

        // Copy the image contents to the canvas
        var ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);

        // Get the data-URL formatted image
        // Firefox supports PNG and JPEG. You could check img.src to
        // guess the original format, but be aware the using "image/jpg"
        // will re-encode the image.
        var imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
        return imageData.data;
    }

    g_img = new Image();
    g_img.src = "00004.png";
    g_img.onload = function () {
        console.log("getBase64Image(g_img)")
        imgData = getBase64Image(g_img)
        console.log(imgData)
        init(imgData, 74, 54);
        animate();
    };
</script>
<body></body>

</html>